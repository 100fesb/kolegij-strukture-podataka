
// triba provjerit ako je prezime manje od 5 slova kako se ponasa

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <malloc.h>
#include <string.h>



#define BUFFER_LENGTH 1024
#define N_LENGTH 1024
#define ERROR -1
#define SUCCESS 0

typedef struct Student* Pozicija;
typedef struct Student* Lista;
typedef struct hashTablica* hashTab;

struct Student{
	int maticniBroj;
	char ime[N_LENGTH];
	char prezime[N_LENGTH];
	Pozicija Next;
};

struct hashTablica{
	int velicinaTablice;
	Lista *hashLista; // zasto pokazivac na pokazivac? jer je hashLista zapravo polje pokazivaca na strukture tipa Student
};

//int StvoriNovogStud(Pozicija);
int CitajIzDat(Pozicija);
int Ispis(Pozicija);
int IzracunajHashKljuc(char*, int);
hashTab InicijalizacijaTablice(int);
int UpisuHashTablicu(Pozicija, hashTab, int);

int main()
{
	struct Student HeadS;
	hashTab HeadT;
	int hashZbroj = 0;
	int velicinaTablice = 11;
	char *V = "Mateafff";

	HeadS.Next = NULL;

	CitajIzDat(&HeadS);

	HeadT = InicijalizacijaTablice(velicinaTablice);

	UpisuHashTablicu(HeadS.Next, HeadT, velicinaTablice);

	

	/*Ispis(HeadS.Next);*/
	system("pause");
	return 0;
}

hashTab InicijalizacijaTablice(int velicinaTablice)
{
	hashTab H = NULL; // stvaramo head element za strukturu tipa hashTablica, zato dolje ide malloc sa sizeof te strukture (a ne velicina tablice)
	int i = 0;

	H = (hashTab)malloc(sizeof(struct hashTablica));
	if (!H) return ERROR;

	H->velicinaTablice = velicinaTablice;

	H->hashLista = (Lista *)malloc(sizeof(Lista)*velicinaTablice); // alociramo prostor za cijelu tablicu (nama 11 mjesta)
	if (!H->hashLista) return ERROR;

	for (i = 0; i < velicinaTablice; i++)
	{
 		H->hashLista[i] = NULL;
   	}

	return H;
}


int IzracunajHashKljuc(char *rijec, int velicinaTab)
{
	int hashZbroj = 0;
	int i = 0;

	for (i = 0; i < 5; i++)
		hashZbroj += rijec[i];

	return hashZbroj % velicinaTab;
}


int CitajIzDat(Pozicija P) {

	Pozicija q = NULL, temp = P; // temp mi sluzi da izbjegnem jednu while petlju -> da zapamti zadnji element i doda na njega - pri tome ne dira Head	
	char* fileName = NULL;		
	FILE* fp = NULL;		

	fileName = (char*)malloc(sizeof(char)* BUFFER_LENGTH);		

		

	if (!fileName)  printf("Greska prilikom alokacije");	

	printf("\nUnesite datoteku za citanje: ");		
	scanf(" %s", fileName);		

	fp = fopen(fileName, "r");		
	if (!fp)  printf("\nDatoteka nije otvorena");		

	while (!feof(fp)) {	
		q = (Pozicija)malloc(sizeof(struct Student));
		fscanf(fp, " %d %s %s", &q->maticniBroj, q->ime, q->prezime);
		q->Next = temp->Next;
		temp->Next = q;

		temp = temp->Next;

	}
	fclose(fp);		

	return 0;		
}

int UpisuHashTablicu(Pozicija P, hashTab H, int velTab)
{
	int i = 0, kljuc;
	Pozicija temp = NULL; // stvaramo temp pokazivac jer triba listu stvorenu iz citanja file-a izbrisat, pa da ne minjamo pokazivace originala

	while (P != NULL){
		

		kljuc = IzracunajHashKljuc(P->prezime, velTab);

		if (H->hashLista[kljuc] != NULL)
			H->hashLista[kljuc]->Next = P;
		else
			H->hashLista[kljuc] = P;
		temp = (Pozicija)malloc(sizeof(struct Student));
		temp = P;
		P = P->Next;
		temp->Next = NULL;
	}
	/*for (i = 0; i < velTab; i++){
		P = (Pozicija)malloc(sizeof(struct Student));
		P->maticniBroj = i;
		H->hashLista[i] = P;
	}*/
}

int Ispis(Pozicija P)
{

	if (!P) return ERROR;

	

	printf("Maticni brojevi:\n");

	while (P != NULL) {
		printf("%d\n", P->maticniBroj);
		P = P->Next;
	}

	return SUCCESS;

}

